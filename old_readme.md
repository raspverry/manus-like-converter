# Manus風AIエージェントシステム実装まとめ

## 実装した主要コンポーネント

1. **エージェントコア**
   - 強化されたエージェントループロジック
   - 高度なコンテキスト管理とサマリゼーション
   - 精緻化されたプランニングモジュール
   - ベクトル検索を活用した強化メモリシステム

2. **ツール群**
   - メッセージツール：ユーザーとのコミュニケーション
   - ファイルツール：ファイルの読み書きや検索
   - シェルツール：コマンド実行とエラー処理
   - ブラウザツール：ウェブブラウジングとPDF抽出
   - 情報ツール：ウェブ検索と関連情報の取得
   - デプロイツール：ポート公開やデプロイ
   - CodeActツール：自動デバッグと高度なコード実行

3. **設定とプロンプト**
   - 体系化されたシステムプロンプト
   - エージェント動作戦略の明示的定義
   - 詳細な設定ファイル
   - メモリ管理ポリシー

## 主要な機能と設計ポイント

1. **CodeActパラダイム**：
   コードの実行によってアクションを表現する手法を採用しています。これにより、単純なツール呼び出しよりも柔軟性の高いアクションが可能になります。コードは自動デバッグ機能も備えており、エラーが発生した場合でも自己修復を試みます。

2. **強化されたエージェントループ**：
   分析 → ツール選択 → 実行 → 観察 のループを繰り返すことで、複雑なタスクをステップバイステップで実行します。エラー発生時の再試行メカニズムや進捗報告機能を備え、より安定した動作を実現します。

3. **計画と分解**：
   複雑なタスクを小さなステップに分解し、todo.mdファイルで進捗を管理します。計画はタスク途中でも柔軟に調整可能で、ユーザーへの定期的な進捗報告を提供します。

4. **高度なメモリシステム**：
   ファイルベースのメモリとベクトルデータベースを組み合わせた拡張メモリにより、コンテキストウィンドウの制限を超えた情報の保持と検索が可能になります。クエリ拡張と検索結果の再ランク付け機能により、より関連性の高い情報を取得できます。

5. **ツールの統合と拡張**：
   PDF抽出ツールや自動デバッグツールなど高度な機能を備え、より多様なタスクに対応できます。ブラウザツールは文書解析能力が強化され、コードツールはエラー処理とデバッグ機能が強化されています。

## 使用開始方法

1. 必要なパッケージをインストール：
```bash
uv add -r requirements.txt
```
2. .envファイルにAPIキーを設定：
```
AZURE_OPENAI_API_KEY=your_azure_api_key
AZURE_OPENAI_ENDPOINT=https://your-resource-name.openai.azure.com
AZURE_OPENAI_API_VERSION=2023-05-15
AZURE_OPENAI_DEPLOYMENT_NAME=your_deployment_name
```
3. エージェントを起動：
```bash
uv run main.py
```

4. オプション：追加ライブラリをインストール（PDFサポート用）：
```bash
uv add PyPDF2 aiohttp
```

## 次のステップと拡張可能性
1. **実際のブラウザ統合**：PlaywrightやSeleniumを使った実際のブラウザ自動化を実装することで、ウェブサイトとの本格的な対話が可能になります。現在のPDF抽出機能のさらなる強化も検討されています。  
2. **実際のデプロイ機能**：実際のクラウドサービス（Vercel、Netlify、AWSなど）との統合を実装することで、本物のデプロイ機能を追加できます。
3. **ベクトルデータベース統合の強化**：現在のFAISSベースのメモリシステムをさらに強化し、より高度な知識検索と記憶機能を実装できます。エンべディングモデルの改善やクラスタリング機能の追加も検討されています。
4. **マルチモーダル対応：画像**、音声、その他のモダリティを処理するための追加ツールを実装することで、より広範なタスクに対応できます。
5. **マルチエージェント協調**：複数のエージェントが協力して作業できるシステムへと拡張することで、並列処理や専門化が可能になります。タスクの依存関係や成果物の共有メカニズムなど、より高度なオーケストレーションが必要です。
6. **UI開発**：ウェブベースまたはデスクトップアプリケーション用のUIを開発して、ユーザービリティを向上させることができます。現在のStreamlit UIの機能強化も検討されています。
7. **セキュリティ強化**：Dockerなどを使用した本格的なサンドボックス環境を実装することで、安全なコード実行が可能になります。権限モデルの追加や出力のサニタイズ機能も必要とされています。
8. **自動デバッグ機能の拡張**：新たに追加されたコード自動デバッグ機能をさらに発展させ、より複雑なエラーにも対応できるようにします。機械学習を活用したエラーパターン認識なども将来的な拡張候補です。
9. **プロンプト最適化フレームワーク**：LLMに対するプロンプトの効果を測定し、自動的に最適化する仕組みを導入することで、エージェントのパフォーマンスをさらに向上させることができます。

## コードカスタマイズのヒント
1. **新しいツールの追加**：tools/ ディレクトリに新しいモジュールを作成し、@tool デコレータを使用して関数を定義します。tool_registry.py に登録するのを忘れないでください。
2. **プロンプトのカスタマイズ**：prompts/system_prompt.txt を編集して、エージェントの動作や役割を調整できます。<メモリ管理>、<コードアクト戦略>、<段階的タスク実行>などのセクションを更新して振る舞いを調整できます。
3. **LLMの変更**：OpenAIのGPT-4oを使用したい場合は、config.py の llm.provider を変更し、適切なAPIキーを設定します。
4. **制約とガードレールの調整**：config.py のセキュリティ設定やシステムプロンプト内のルールを調整して、エージェントの動作範囲を制御できます。
5. **メモリシステムのカスタマイズ**：core/enhanced_memory.py のクエリ拡張や再ランク付けロジックを調整して、特定のドメインに合わせた知識検索を最適化できます。

## 全体アーキテクチャとフロー
まず、main.py で CLI または Streamlit WebUI を起動し、そこからエージェント（Agent）を作成・実行しています。この構成は、以下のような "Manus風" のフローを実現している点で良いアプローチです:

1. ユーザーがタスクを入力する（CLI または UI）
2. そのタスクをエージェントへ渡す
3. エージェントが Planner でプランを作成
4. 作成したプランを イベントストリーム (Context) に登録
5. 繰り返し (ループ) で LLM に問い合わせ → LLMが「ツール呼び出し（関数）」をJSONで返す → 実行 → 観察結果をイベントとして再度 LLM に返す
6. エラーが発生した場合は自動再試行や自動デバッグを試み、結果をユーザーに通知
7. 最終的に idle あるいはmax_iterations を超えたら終了

## 実際の動作フロー
1. ユーザーが Streamlit UI に「○○して」と入力
2. エージェントが "プラン" を生成し、イベントストリームに追加
3. LLM が「shell_exec」や「file_write」などの JSON を返す → 実行 → 結果を観察
4. エラーが発生した場合は「codeact_auto_debug」などを使って自己修復を試みる
5. 進捗状況を定期的にユーザーに報告
6. 複雑な情報が必要な場合「browser_extract_pdf」などの拡張ツールも活用
7. 必要があればユーザーに message_ask_user でブロック質問
8. 最後に idle が返ったら終了
